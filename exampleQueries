$> FIRST SET OF EXAMPLES 

<mi>3</mi><mo>‚â§</mo><mi>4</mi>

<mi>3</mi><mo>√ó</mo><mi>4</mi>

<mi>3</mi><mo>div</mo><mi>4</mi>

<mi>3</mi><mo>mod</mo><mi>4</mi>

<mo>]</mo><mi>x</mi><mo>[</mo>

<msup><mi>3</mi><mi>4</mi></msup>


$> SECOND SET OF EXAMPLES

// Sequence Arguments / ArgSeq
<mi>3</mi><mo>+</mo><mi>4</mi><mo>+</mo><mi>5</mi>  


// Notation as an argument of another notation (BOTH mod(3, 4+5) AND +(3 mod 4, 5) are detected)
<mi>3</mi><mo>mod</mo><mi>4</mi><mo>+</mo><mi>5</mi> 


CURRENT GOAL:

Precedences (make 3 mod 4 + 5  have only the reading +(3 mod 4, 5))


Not working:
<mrow>
         <mrow>
                <mi>c</mi>
                <mo>=</mo>
                <mrow>
                    <mo>(</mo>
                    <mi>a</mi>
                    <mo>+</mo>
                    <mrow>
                        <mi>b</mi>
                        <mo>‚Å¢</mo>
                        <mo>ùëñ</mo>
                    </mrow>
                    <mo>)</mo>
                </mrow>
            </mrow>
        </mrow>
Problem: Encoding problems
Status: Working

Not working:
	<mi>4</mi>
	<mo>+</mo>
	<mi>3</mi>
	<mo>mod</mo>
	<mi>5</mi>
Explanation: If we were to use standard techniques for parsing, the grammar is good enough to make it work, however because of my optimizations I also get rule matches
from incomplete input matches, as follows: 
The grammar starts reading in 4+3, finds out a rule matched, creates an event, even
though the input is cannot be fully matched because of precedences.

Solution: Use standard parsing techniques, but then the performance would be too slow
for any kind of practical applications (I'm only using the first 50-100 parse trees to 
get the arguments or rules)

